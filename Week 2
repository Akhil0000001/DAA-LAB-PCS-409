/*I. Given a sorted array of positive integers containing few duplicate elements, design

an algorithm and implement it using a program to find whether the given key

element is present in the array or not. If present, then also find the number of copies

of given key. (Time Complexity = O(log n))

Input format:

The first line contains number of

test cases, T. For each test case,

there will be three input lines. First

line contains n (the size of array).

Second line contains space-separated integers describing array.

Third line contains the key element that need to be searched in the array.

Output format:

The output will have T number of lines.

For each test case T, output will be the key element and its number of copies in the

array if the key element is present in the array otherwise print “ Key not present”. */



#include<iostream>

#include<fstream>

using namespace std;



int binarySearch(int arr[],int s,int e,int key,bool first){

    //first if true find first occurance else last occurance

    int pos=-1;

    while(s<=e){

        int mid=s+(e-s)/2;

        if(arr[mid]<key){

            s=mid+1;

        }

        else if(arr[mid]>key){

            e=mid-1;

        }else{

            pos=mid;

            if(first){

                e=mid-1;

            }else{

                s=mid+1;

            }

        }

    }

    return pos;

}

void search(int arr[],int n,int key){

    ofstream out("output.txt",ios::app);

    int first=binarySearch(arr,0,n-1,key,true);

    if(first == -1){

        out<<"Key not Present"<<endl;

        return;

    }

    int last=binarySearch(arr,0,n-1,key,false);

    int occ=last-first+1;

    out<<key<<" - "<<occ<<endl;

    out.close();

}



int main(){

    ifstream inp("input.txt");

    int n,T;// T== number of testcases

    inp>>T;

    while(T--){

        inp>>n;

        int key,arr[n];

        for(int i=0;i<n;i++){

            inp>>arr[i];

        }

        inp>>key;

        search(arr,n,key);

    }

    inp.close();

}



/* II. Given a sorted array of positive integers, design an algorithm and implement it using a program to find three indices i, j, k such that arr[i] + arr[j] = arr[k]. Input format: The first line contains number of test cases, T. For each test case, there will be two input lines. First line contains n (the size of array). Second line contains space-separated integers describing array. Output: The output will have T number of lines. For each test case T, print the value of i, j and k, if found else print “No sequence found”. */





#include<bits/stdc++.h>

#include<fstream>

using namespace std;



void searchSquence(int arr[],int n){

    ofstream out("output.txt",ios::app);

    unordered_map<int,int> mpp;

    for(int i=2;i<n;i++){

        mpp[arr[i]]=i;

    }

    for(int i=0;i<n-2;i++){

        for(int j=i+1;j<n-1;j++){

            if(mpp.count(arr[i]+arr[j])){

                out<<i<<" , "<<j<<" , "<<mpp[arr[i]+arr[j]]<<endl;

                return;

            }

        }

    }

    out<<"No Sequence found"<<endl;

    out.close();

}



int main(){

    ifstream inp("input.txt");

    int n,T;// T== number of testcases

    inp>>T;

    while(T--){

        inp>>n;

        int arr[n];

        for(int i=0;i<n;i++){

            inp>>arr[i];

        }

        searchSquence(arr,n);

    }

    inp.close();

}

/*III. Given an array of nonnegative integers, design an algorithm and a program to count the number of pairs of integers such that their difference is equal to a given key, K.*/



#include<iostream>

#include<fstream>

using namespace std;



void countPair(int arr[],int n,int key){

  ofstream out("output.txt",ios::app);

  int cnt=0;

  for(int i=0;i<n;i++){

    for(int j=i+1;j<n;j++){

      if(abs(arr[i]-arr[j])==key)

        cnt++;

    }

  }

  out<<cnt<<endl;

}



int main()

{

    int n,T;

    ifstream inp("input.txt");

    

    inp>>T;                   //total number of test cases

    while(T--){

        inp>>n;

        int key,arr[n];

        for(int i=0;i<n;i++){

            inp>>arr[i];

        }

        inp>>key;

        countPair(arr,n,key);

    }

    inp.close();

    return 0;

}

